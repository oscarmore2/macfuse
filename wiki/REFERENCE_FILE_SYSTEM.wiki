#summary Using the MacFUSE Reference File System

= Using the MacFUSE Reference File System =

File systems are intricate and complex beings. In modern operating systems, file systems are intimately tied to numerous other subsystems, in particular, the virtual memory subsystem. Information flows in and out of file systems through myriad channels. Writing a file system is an extremely complex programming task. MacFUSE simplifies this task by orders of magnitude, allowing developers to create file systems using a simple user-mode API along with other familiar and rich programming libraries available to them. Still, any reasonably complete file system, especially one that is writable, will still be complex enough to require very careful design, implementation, and testing on part of the developer. Subtleties and caveats abound in the world of file systems in general, but on Mac OS X, even subtleties have their own subtleties. Mac OS X has so many "layers" and APIs that you never can be too sure that your file system will work as expected (by the end user) under all circumstances. Therefore, it is paramount to test your user-space file system the best you can.

The MacFUSE user-space library comes with a "reference" file system that can be an important tool in helping you understand MacFUSE behavior and use that knowledge to test your file system better. The reference file system is called `fusexmp_fh`. It can be found in the `example/` subdirectory in the library source. The file system is easy to compile. You can either do so manually as follows. We will assume that you have the MacFUSE svn tree checked out under `/work/macfuse/`. (Note that version numbers etc. might not match what's shown here.)

{{{
$ cd /work/macfuse
$ ./tools/build_lib.sh
Using MacFUSE source root /work/macfuse
Initiating Universal build of libfuse for Mac OS X "Leopard"
Using package name fuse-2.7.3
...
fuse-2.7.3 compiled OK in /tmp/fuse-2.7.3

$
}}}

Once compilation succeeds, a runnable `fusexmp_fh` can be found in the `/tmp/fuse-2.7.3/example/` directory.

`fusexmp_fh` performs a "loopback" mount through MacFUSE. You can use it to take an existing directory, say `/d` and mount it on top of another directory, say `/Volumes/loopback`. Then, as you access and manipulate files and folders in `/Volumes/loopback`, your accesses will go from the kernel (MacFUSE) to the user-mode `fusexmp_fh` program. `fusexmp_fh` serves file system requests by simply forwarding them to the appropriate C library calls (which in turn will forward to system calls). For example, its implementation of `read` and `write` simply forward to the `read` and `write` system calls, respectively. Since `fusexmp_fh` does so little itself, it is valuable as a tool that lets you focus on MacFUSE behavior rather than the specifics of the user-mode file system. If you are having difficulty in getting some behavior right in your file system, try the same tests with `fusexmp_fh` and see what it does. You might be able to determine what you are doing (or not doing) that's causing the issue. You might also find a bug in `fusexmp_fh` and/or MacFUSE.

To run `fusexmp_fh` in high-fidelity mode (that is, as close to a "real" Mac OS X file system as possible), make sure that your backing directory (the one that you remount through `fusexmp_fh`) resides on an HFS+ volume. You can create a directory called `/d` for this purpose and then mount it as follows:

{{{
$ mkdir /d # This is the backing store directory; the volume's data will actually reside in here
$ mkdir /Volumes/loopback # This is where we'll mount
$ sudo ./fusexmp_fh /Volumes/loopback -omodules=threadid:subdir,subdir=/d -onative_xattr -oallow_other
}}}

The `threadid` stacking module in conjunction with the `allow_other` mount-time option and the fact that you run `fusexmp_fh` as root lets you run the loopback file system in multi-user mode.

The `subdir` stacking module in conjunction with the `subdir=/d` module option lets you limit `fusexmp_fh` to a single directory. Normally, `fusexmp_fh` would actually remount the root file system. It's nicer and cleaner to contain experimentation to one directory. Note that if you conduct file system tests that involve long path names, the `fusexmp_fh` program will have to work with path names that are longer on the back-end side: for example, if a call comes in to create a file `/foo`, `fusexmp_fh` will attempt to create `/d/foo` on the underlying file system. Thus, the back-end will hit the path name length limit earlier than the front-end.